package node;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.Set;
import java.util.stream.Collectors;

import dataflow.Request;
import strategies.NodeLinkStrategy;

public final class Distributor extends Receiver<Producer> implements Observer {
    private static final double PROFIT_COEFFICIENT = 0.2;
    private static final double JESUS_NUMBER = 10;

    private final long contractLength;
    private long infrastructureCost;
    private final long energyNeeded;
    private final String producerStrategy;

    private long prevProductionCost = -1;
    private long productionCost = -1;
    private long money;
    private final Map<Node, Long> consumers = new LinkedHashMap<Node, Long>();
    private long consumersCount = 0;

    private boolean producersChanged = true;

    private final Map<Long, List<Long>> monthlyStats;
    private long month;

    protected Distributor(final long id, final long contractLength, final long budget,
            final long infrastructureCost, final long energyNeeded, final String producerStrategy,
            final NodeLinkStrategy<Producer> linkStrategy) {
        super(id, linkStrategy);

        this.contractLength = contractLength;
        this.money = budget;
        this.infrastructureCost = infrastructureCost;
        this.energyNeeded = energyNeeded;
        this.producerStrategy = producerStrategy;

        monthlyStats = new HashMap<Long, List<Long>>();
        month = 0;
    }

    @Override
    public boolean canChoose() {
        if (producersChanged) {
            this.sources.forEach(producer -> {
                producer.request((new Request(this)).setCustomer(-1));
                producer.deleteObserver(this);
            });

            producersChanged = false;

            return true;
        }

        return false;
    }

    @Override
    public void afterChoose() {
        final double cost = this.sources.stream()
                .mapToDouble(producer -> producer.getProductionCost()).sum();

        productionCost = Math.round(Math.floor(cost / JESUS_NUMBER));
        if (prevProductionCost == -1) {
            prevProductionCost = productionCost;
        }

        final List<Long> idList = this.sources.stream().map(producer -> producer.getId())
                .collect(Collectors.toList());
        monthlyStats.put(month, idList);

        this.sources.forEach(producer -> {
            producer.request((new Request(this)).setCustomer(1));
            producer.addObserver(this);
        });
    }

    /**
     * Simulate a passing of a month.
     */
    @Override
    public void update() {
        // We need the previous consumer count to compute the price of a contract
        // That's because customers with 0 remaining time are immediately eliminated

        prevProductionCost = productionCost;

        consumersCount = consumers.size();
        consumers.replaceAll((k, v) -> v - 1);
        consumers.entrySet().removeIf(e -> e.getValue() <= 0);
        month++;
    }

    /**
     * The method that defines the engine of the simulations. It handles requests by
     * changing it's states and/or sending requests to other nodes. The requests can
     * be sent either to source nodes or to the nodes that sent this request (by
     * reflecting the request)
     */
    @Override
    public void request(final Request request) {
        if (this.isOut()) {
            return;
        }

        if (request.getEnergy() > 0) {
            request.reflect(this, (new Request(this)).setTax(1));

            return;
        }

        // Request generated by the government to send money to it
        if (request.getTax() > 0) {
            final long tax = infrastructureCost + prevProductionCost * consumers.size();

            money -= tax;
            request.reflect(this, (new Request(this)).setMoney(-tax));

            if (money < 0) {
                this.setOut(true);
            }

            return;
        }

        // Request to receive money
        if (request.getMoney() < 0) {
            money -= request.getMoney();
        }

        // Request to update the customer database
        // It is generated by a customer
        if (request.getCustomer() > 0) {
            if (!consumers.containsKey(request.getSource())) {
                consumers.put(request.getSource(), contractLength);
            }
        } else if (request.getCustomer() < 0) {
            consumers.remove(request.getSource());
        }
    }

    private long getProfit() {
        return Math.round(Math.floor(PROFIT_COEFFICIENT * prevProductionCost));
    }

    /**
     * Return the price of a contract with this distributor.
     *
     * @return
     */
    public long getPrice() {
        final long price = prevProductionCost + getProfit();

        if (consumersCount > 0) {
            return Math.round(price + Math.floor(infrastructureCost / consumersCount));
        }
        return price + infrastructureCost;
    }

    public long getContractLength() {
        return contractLength;
    }

    public Set<Node> getConsumers() {
        return consumers.keySet();
    }

    public long getMoney() {
        return money;
    }

    public long getEnergyNeeded() {
        return energyNeeded;
    }

    public String getProducerStrategy() {
        return producerStrategy;
    }

    public void setInfrastructureCost(final long infrastructureCost) {
        this.infrastructureCost = infrastructureCost;
    }

    public void setProducersChanged(final boolean producersChanged) {
        this.producersChanged = producersChanged;
    }

    public Map<Long, List<Long>> getMonthlyStats() {
        return monthlyStats;
    }

    @Override
    public void update(final Observable o, final Object arg) {
        producersChanged = true;
    }
}
